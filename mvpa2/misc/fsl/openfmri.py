# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# vi: set ft=python sts=4 ts=4 sw=4 et:
### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
#
#   See COPYING file distributed along with the PyMVPA package for the
#   copyright and license terms.
#
### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
"""Utility functions to prepare FSL GLM analysis from OpenFMRI datasets."""

__docformat__ = 'restructuredtext'


def mk_level1_fsf(
        of,
        model,
        subj,
        task,
        run,
        bold_fname=_opj('%(subdir)s', 'BOLD', 'task%(task)03d_run%(run)03d',
                        'bold.nii.gz'),
        # TODO more flexible output location
        fsf_fname=_opj('%(modeldir)s', 'task%(task).3i_run%(run).3i_1stlvl.fsf'),
        # TODO not per-subject images by force
        brain_img_fname=_opj('%(subdir)s', 'anatomy', 'highres001_brain.nii.gz'),
        brain_mask_fname=None,
        example_func_fname=None,
        # TODO if relative, relative to BOLD
        confound_fname=_opj('%(subdir)s', 'BOLD', 'task%(task)03d_run%(run)03d',
                            'qa', 'confound.txt'),
        fsfstub_fname=None,
        result_dir=None,
        smoothing_kernelsize=0,
        use_inplane=False,
        nonlin_reg=False,
        add_temporal_deriv=True,
        skipvols=0,
        tr=None,
        overwrite_results=True,
        initxfm2std_fname=None,
        ):
    """
    Based on mk_level1_fsf.py by Russell Poldrack (Simplified BSD license).

    TODO:

      - orthogonalization is disabled

      - add support for these:

        # Initial structural space registration initialisation transform
        set fmri(init_initial_highres) ""

        # Structural space registration initialisation transform
        set fmri(init_highres) ""
    """

    import nibabel as nb

    # few convenience shortcuts
    subdir = _opj(of.basedir, 'sub%03d' % subj)
    modelbasedir = _opj(subdir, 'model')
    modeldir= _opj(modelbasedir, 'model%03d' % model)

    # read the conditions_key file, throw away any condition that is not relevant for
    # the current task
    conditions = [c for c in of.get_model_conditions(model) if c['task'] == task]

    expandvars = {
        'subdir': subdir,
        'modeldir': modeldir,
        'task': task,
        'run': run,
    }

    # check for orthogonalization file
    orth={}
    ##orthfile = _opj(of.basedir, 'models', 'model%03d' % model, 'orthogonalize.txt')
    ##if os.path.exists(orthfile):
    ##    f=open(orthfile)
    ##    for l in f.readlines():
    ##        orth_tasknum=int(l.split()[0].replace('task',''))
    ##        if orth_tasknum==task:
    ##            orth[int(l.split()[1])]=int(l.split()[2])
    ##    f.close()

    # check for QA dir
    #qadir='%s/BOLD/task%03d_run%03d/QA'%(subdir,task,run)

    contrasts_all = of.get_model_contrasts(model,)
    contrasts=[]
    if contrasts_all.has_key(task):
        contrasts=contrasts_all[task]

    scan_key = of.get_scan_properties()

    # write to a file or into a string
    if fsf_fname is None:
        from cStringIO import StringIO
        outfile = StringIO()
    else:
        outfilename = fsf_fname % expandvars
        outfile = open(outfilename,'w')

    outfile.write('# Automatically generated by mk_fsf.py\n')

    # first get common lines from stub file
    if not fsfstub_fname is None:
        stubfile=open(fsfstub_fname,'r')
        for l in stubfile:
            outfile.write(l)
        stubfile.close()

    # figure out how many timepoints there are
    bold_img_path = bold_fname % expandvars
    bold_img = nb.load(bold_img_path)
    # should be 4D
    ntp = bold_img.shape[3]

    if tr is None:
        # try our luck with the image header
        hdr = bold_img.get_header()
        tinc = hdr.get_zooms()[3]
        unit = hdr.get_xyzt_units()[1]
        if unit == 'sec':
            tr = tinc
        elif unit == 'msec':
            tr = tinc / 1000.
        else:
            raise ValueError("unkown time unit, cannot determine TR")

    outfile.write('\n\n### AUTOMATICALLY GENERATED PART###\n\n')
    # now add custom lines
    outfile.write( 'set fmri(regstandard_nonlinear_yn) %d\n' % int(nonlin_reg))
    # Delete volumes
    outfile.write('set fmri(ndelete) %d\n' % skipvols)

    if result_dir is None:
        result_dir = _opj('%(modeldir)s', 'task%(task)03d_run%(run)03d.feat') \
                          % expandvars
    outfile.write('set fmri(outputdir) "%s"\n' % (result_dir,))
    outfile.write('set feat_files(1) "%s"\n' % (_stripext(bold_img_path),))
    if use_inplane is True:
        # XXX THIS IS TODO
        outfile.write('set fmri(reginitial_highres_yn) 1\n')
        outfile.write('set initial_highres_files(1) "%s/anatomy/inplane001_brain.nii.gz"\n'
                      % subdir)
    else:
        outfile.write('set fmri(reginitial_highres_yn) 0\n')

    outfile.write('set highres_files(1) "%s"\n'
                  % (_stripext(brain_img_fname % expandvars),))
    outfile.write('set fmri(npts) %d\n' % ntp)
    outfile.write('set fmri(tr) %0.2f\n' % tr)
    nevs=len(conditions)
    outfile.write('set fmri(evs_orig) %d\n' % nevs)
    # TODO support other convolution schemes
    outfile.write('set fmri(evs_real) %d\n' % (2 * nevs))
    outfile.write('set fmri(smooth) %d\n' % smoothing_kernelsize)
    outfile.write('set fmri(ncon_orig) %d\n'
                  % (len(conditions) + 1 + len(contrasts)))
    outfile.write('set fmri(ncon_real) %d\n'
                  % (len(conditions) + 1 + len(contrasts)))

    # loop through EVs
    convals_real = np.zeros(nevs * 2)
    convals_orig = np.zeros(nevs)
    # XXX what is this?
    empty_evs=[]

    for ev, cond in enumerate(conditions):
        outfile.write('\n\nset fmri(evtitle%d) "%s"\n'
                      % (ev + 1, cond['name']))
        condfile = _opj('%(modeldir)s', 'onsets', 'task%(task)03d_run%(run)03d',
                       'cond%03d.txt' % (ev + 1)) % expandvars
        if os.path.exists(condfile):
            outfile.write('set fmri(shape%d) 3\n'%(ev + 1))
            outfile.write('set fmri(custom%d) "%s"\n'%(ev + 1, condfile))
        else:
             # shape 10 is "empty (all zeros)"
             outfile.write('set fmri(shape%d) 10\n' % (ev + 1))
             print '%s is missing, using empty EV' % condfile
             empty_evs.append(ev + 1)

        outfile.write('set fmri(convolve%d) 3\n' % (ev + 1))
        outfile.write('set fmri(convolve_phase%d) 0\n' % (ev + 1))
        outfile.write('set fmri(tempfilt_yn%d) 1\n' % (ev + 1))
        outfile.write('set fmri(deriv_yn%d) %i\n'
                      % (ev + 1, add_temporal_deriv))

        # first write the orth flag for zero, which seems to be turned on whenever
        # anything is orthogonalized
        if orth.has_key(ev + 1):
                outfile.write('set fmri(ortho%d.0) 1\n' % int(ev + 1))
        else:
                outfile.write('set fmri(ortho%d.0) 0\n' % int(ev + 1))
        for evn in range(1, nevs + 1):
            if orth.has_key(ev + 1):
                if orth[ev + 1] == evn:
                    outfile.write('set fmri(ortho%d.%d) 1\n' % (ev + 1, evn))
                else:
                    outfile.write('set fmri(ortho%d.%d) 0\n' % (ev + 1, evn))
            else:
                outfile.write('set fmri(ortho%d.%d) 0\n' % (ev + 1, evn))

        # default contrast setup
        # make a T contrast for each EV
        outfile.write('set fmri(conpic_real.%d) 1\n' % (ev + 1))
        outfile.write('set fmri(conpic_orig.%d) 1\n' % (ev + 1))
        outfile.write('set fmri(conname_real.%d) "%s"\n'
                      % (ev + 1, cond['name']))
        outfile.write('set fmri(conname_orig.%d) "%s"\n'
                      % (ev + 1, cond['name']))
        for evt in range(nevs * 2):
            outfile.write('set fmri(con_real%d.%d) %d\n'
                          %(ev + 1, evt + 1, int(evt == (ev * 2))))
            if (evt == (ev * 2)):
                convals_real[evt] = 1
        for evt in range(nevs):
            outfile.write('set fmri(con_orig%d.%d) %d\n'
                          % (ev + 1, evt + 1, int(evt == ev)))
            if (evt == ev):
                convals_orig[evt] = 1

    if len(empty_evs) > 0:
        empty_ev_file = open(
                _opj('%(modeldir)s', 'onsets', 'task%(task)03d_run%(run)03d',
                     'empty_evs.txt') % expandvars, 'w')
        for eev in empty_evs:
            empty_ev_file.write('%d\n' % eev)
        empty_ev_file.close()

    # make one additional contrast across all conditions
    outfile.write('set fmri(conpic_real.%d) 1\n' % (ev + 2))
    outfile.write('set fmri(conpic_orig.%d) 1\n' % (ev + 2))
    outfile.write('set fmri(conname_real.%d) "all"\n' % (ev + 2))
    outfile.write('set fmri(conname_orig.%d) "all"\n' % (ev + 2))

    for evt in range(nevs * 2):
            outfile.write('set fmri(con_real%d.%d) %d\n'
                          %(ev + 2, evt + 1, convals_real[evt]))
    for evt in range(nevs):
            outfile.write('set fmri(con_orig%d.%d) %d\n'
                          % (ev + 2, evt + 1, convals_orig[evt]))

   # add custom contrasts
    if len(contrasts) > 0:
        contrastctr = ev + 3
        for c in contrasts.iterkeys():
            outfile.write('set fmri(conpic_orig.%d) 1\n' % contrastctr)
            outfile.write('set fmri(conpic_real.%d) 1\n' % contrastctr)
            outfile.write('set fmri(conname_real.%d) "%s"\n' % (contrastctr, c))
            outfile.write('set fmri(conname_orig.%d) "%s"\n' % (contrastctr, c))
            cveclen = len(contrasts[c])
            con_real_ctr = 1
            for evt in range(nevs):
                outfile.write('set fmri(con_real%d.%d) %s\n'
                              % (contrastctr,
                                 con_real_ctr,
                                 contrasts[c][evt]))
                outfile.write('set fmri(con_real%d.%d) 0\n'
                              % (contrastctr, con_real_ctr + 1))
                con_real_ctr += 2
            for evt in range(nevs):
                if evt < cveclen:
                    outfile.write('set fmri(con_orig%d.%d) %s\n'
                                  % (contrastctr, evt + 1, contrasts[c][evt]))
                else:
                    outfile.write('set fmri(con_orig%d.%d) 0\n'
                                  % (contrastctr, evt + 1))
            contrastctr += 1

    # Add confound EVs text file
    if not confound_fname is None:
        confoundfile = confound_fname % expandvars
        if os.path.exists(confoundfile):
            outfile.write('set fmri(confoundevs) 1\n')
            outfile.write('set confoundev_files(1) "%s"\n' % confoundfile)
        else:
            outfile.write('set fmri(confoundevs) 0\n')
    else:
        outfile.write('set fmri(confoundevs) 0\n')

    if overwrite_results:
        outfile.write('set fmri(overwrite_yn) 1\n')

    if not brain_mask_fname is None:
        # don't rely on BET but use a specified mask
        outfile.write('set fmri(alternative_mask) "%s"\n'
                      % (brain_mask_fname % expandvars,))

    if not example_func_fname is None:
        # don't rely on extracting a example image from the BOLD input,
        # but use a specified image
        outfile.write('set fmri(alternative_example_func) "%s"\n'
                      % (example_func_fname % expandvars,))

    # Standard space registration initialisation transform
    if not initxfm2std_fname is None:
        outfile.write('set fmri(init_standard) "%s"\n'
                      % (initxfm2std_fname % expandvars,))

    if fsf_fname is None:
        # return the FSF file content as a string
        outfile.seek(0)
        fsf = outfile.read()
        outfile.close()
        return fsf
    else:
        # return the filename
        outfile.close()
        return outfilename


def mk_level2_fsf(
        of,
        model,
        subj,
        task=None,
        runs=None,
        fsf_fname=_opj('%(modeldir)s', 'task%(task)03d_2ndlvl.fsf'),
        feat_inputdir=_opj('%(modeldir)s', 'task%(task).3i_run%(run).3i.feat'),
        fsfstub_fname=None,
        result_dir=None,
        overwrite_results=True,
        ):
    """
    Based on mk_level2_fsf.py by Russell Poldrack (Simplified BSD license).

    """
    # try to determine the task automatically from the model
    task = set([c['task'] for c in of.get_model_conditions(model)])
    if not len(task) == 1:
        raise ValueError("ambiguous task list for model %.3i, "
                         "use `task` argument to disambiguate" % (model,))
    task = list(task)[0]

    if runs is None:
        # process all runs in the absence of a selection
        runs = of.get_task_bold_run_ids(task)[subj]

    # few convenience shortcuts
    subdir = _opj(of.basedir, 'sub%03d' % subj)
    modelbasedir = _opj(subdir, 'model')
    modeldir= _opj(modelbasedir, 'model%03d' % model)

    # read the conditions_key file, throw away any condition that is not relevant for
    # the current task
    conditions = [c for c in of.get_model_conditions(model) if c['task'] == task]

    expandvars = {
        'subdir': subdir,
        'modeldir': modeldir,
        'task': task,
    }

    # load custom contrasts
    contrasts = of.get_model_contrasts(model,).get(task, {})

    # write to a file or into a string
    if fsf_fname is None:
        from cStringIO import StringIO
        outfile = StringIO()
    else:
        outfilename = fsf_fname % expandvars
        outfile = open(outfilename,'w')

    outfile.write('# Automatically generated\n')

    # first get common lines from stub file
    if not fsfstub_fname is None:
        stubfile=open(fsfstub_fname,'r')
        for l in stubfile:
            outfile.write(l)
        stubfile.close()

    # now add custom lines

    # TODO
    # first check for empty EV file
    #empty_evs=[]
    #for r in range(len(runs)):
    #    if os.path.exists("%s/%s/sub%03d/model/model%03d/onsets/task%03d_run%03d/empty_evs.txt"%(basedir,taskid,subnum, modelnum,tasknum,runs[r])):
    #        evfile=open("%s/%s/sub%03d/model/model%03d/onsets/task%03d_run%03d/empty_evs.txt"%(basedir,taskid,subnum,modelnum,tasknum,runs[r]),'r')
    #        empty_evs=[int(x.strip()) for x in evfile.readlines()]
    #        evfile.close()

    outfile.write('\n\n### AUTOMATICALLY GENERATED PART###\n\n')

    if result_dir is None:
        result_dir = _opj('%(modeldir)s', 'task%(task)03d_2ndlvl.gfeat') % expandvars
    outfile.write('set fmri(outputdir) "%s"\n' % (result_dir,))
    outfile.write('set fmri(npts) %d\n' % len(runs)) # number of runs
    outfile.write('set fmri(multiple) %d\n' % len(runs)) # number of runs
    outfile.write('set fmri(ncopeinputs) %d\n'
                  % int(len(conditions) + 1 + len(contrasts))) # nmbr of copes

    for r in range(len(runs)):
        rexpandvars = expandvars.copy()
        rexpandvars['run'] = runs[r]
        outfile.write('set feat_files(%d) "%s"\n'
                      % (int(r+1), feat_inputdir % rexpandvars))
        outfile.write('set fmri(evg%d.1) 1\n' % int(r + 1))
        outfile.write('set fmri(groupmem.%d) 1\n' % int(r + 1))
        # TODO: remove here when TODO below is dealt with

    for c in range(len(conditions) + 1 + len(contrasts)): # nmbr of copes
        outfile.write('set fmri(copeinput.%d) 1\n' % int(c + 1))
    # TODO
    # need to figure out if any runs have empty EVs and leave them out
    #    if not c+1 in empty_evs:
    #        outfile.write('set fmri(copeinput.%d) 1\n'%int(c+1))
    #    else:
    #         outfile.write('set fmri(copeinput.%d) 0\n'%int(c+1))

    if fsf_fname is None:
        # return the FSF file content as a string
        outfile.seek(0)
        fsf = outfile.read()
        outfile.close()
        return fsf
    else:
        # return the filename
        outfile.close()
        return outfilename
